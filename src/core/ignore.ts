/**
 * Ignore file generation for mgrep indexing
 */

import * as fs from 'fs';
import * as path from 'path';
import { buildIgnoreContent, getRepoIgnoreConfig, GLOBAL_IGNORE_PATTERNS } from './ignore-rules.js';
import { getRepoPath, getEnabledRepos } from './manifest.js';
import type { Manifest, RepoConfig } from './types.js';

export interface IgnoreBuildOptions {
  dryRun?: boolean;
  global?: boolean;  // Use global mode instead of per-repo
}

export interface IgnoreBuildResult {
  repoId: string;
  repoName: string;
  path: string;
  content: string;
  written: boolean;
  ruleCount: number;
}

export interface IgnoreBuildSummary {
  mode: 'perRepo' | 'global';
  results: IgnoreBuildResult[];
  totalRules: number;
  filesWritten: number;
}

/**
 * Count non-empty, non-comment lines in ignore content
 */
function countRules(content: string): number {
  return content
    .split('\n')
    .filter((line) => {
      const trimmed = line.trim();
      return trimmed.length > 0 && !trimmed.startsWith('#');
    }).length;
}

/**
 * Build ignore file for a single repo
 */
export function buildRepoIgnore(repo: RepoConfig): { content: string; ruleCount: number } {
  const content = buildIgnoreContent(repo.id);
  const ruleCount = countRules(content);
  return { content, ruleCount };
}

/**
 * Write ignore file for a single repo
 */
export function writeRepoIgnore(
  repo: RepoConfig,
  root: string,
  options: IgnoreBuildOptions = {}
): IgnoreBuildResult {
  const repoPath = getRepoPath(root, repo.localDir);
  const ignorePath = path.join(repoPath, '.mgrepignore');

  const { content, ruleCount } = buildRepoIgnore(repo);

  let written = false;
  if (!options.dryRun) {
    // Only write if repo directory exists
    if (fs.existsSync(repoPath)) {
      fs.writeFileSync(ignorePath, content, 'utf-8');
      written = true;
    }
  }

  return {
    repoId: repo.id,
    repoName: repo.name,
    path: ignorePath,
    content,
    written,
    ruleCount,
  };
}

/**
 * Build global ignore file (all repos in one file)
 */
export function buildGlobalIgnore(manifest: Manifest): { content: string; ruleCount: number } {
  const lines: string[] = [
    '# ==============================================',
    '# REFERENCE REPOS - UNIFIED .mgrepignore',
    '# ==============================================',
    '# AUTO-GENERATED by: refrepo ignore build --global',
    '# Only index content relevant to: TanStack Start + Convex + Better Auth + React',
    '#',
    '# Structure:',
    '#   1. Global exclusions (apply to all repos)',
    '#   2. Per-repo specific exclusions',
    '# ==============================================',
    '',
  ];

  // Add global patterns section
  lines.push('# ------------------------------------------');
  lines.push('# GLOBAL EXCLUSIONS (all repos)');
  lines.push('# ------------------------------------------');
  lines.push('');

  // Use patterns from GLOBAL_IGNORE_PATTERNS with **/ prefix for global matching
  for (const pattern of GLOBAL_IGNORE_PATTERNS) {
    // Handle negation patterns - ! must come before **/
    if (pattern.startsWith('!')) {
      lines.push(`!**/${pattern.slice(1)}`);
    } else {
      lines.push(`**/${pattern}`);
    }
  }
  lines.push('');

  // Add per-repo sections
  const enabledRepos = getEnabledRepos(manifest);

  for (const repo of enabledRepos) {
    const repoConfig = getRepoIgnoreConfig(repo.id);

    if (repoConfig && repoConfig.dropPaths.length > 0) {
      lines.push('# ------------------------------------------');
      lines.push(`# ${repo.name.toUpperCase()}: ${repoConfig.notes || 'Specific exclusions'}`);
      lines.push('# ------------------------------------------');

      for (const dropPath of repoConfig.dropPaths) {
        lines.push(`${repo.localDir}/${dropPath}`);
      }
      lines.push('');
    }
  }

  // Add custom ignores from manifest (user-added via suggest --apply)
  if (manifest.customIgnores && manifest.customIgnores.length > 0) {
    lines.push('# ------------------------------------------');
    lines.push('# CUSTOM IGNORES (from refrepo suggest --apply)');
    lines.push('# ------------------------------------------');

    for (const pattern of manifest.customIgnores) {
      lines.push(pattern);
    }
    lines.push('');
  }

  // Add footer
  lines.push('# ------------------------------------------');
  lines.push('# Non-essential files');
  lines.push('# ------------------------------------------');
  lines.push('mgrep-test.txt');
  lines.push('');

  const content = lines.join('\n');
  const ruleCount = countRules(content);

  return { content, ruleCount };
}

/**
 * Write all ignore files (per-repo or global mode)
 */
export function writeIgnoreFiles(
  manifest: Manifest,
  options: IgnoreBuildOptions = {}
): IgnoreBuildSummary {
  const results: IgnoreBuildResult[] = [];
  const root = manifest.defaultRoot;

  if (options.global) {
    // Global mode: single file at root
    const { content, ruleCount } = buildGlobalIgnore(manifest);
    const globalPath = path.join(root, '.mgrepignore');

    let written = false;
    if (!options.dryRun && fs.existsSync(root)) {
      fs.writeFileSync(globalPath, content, 'utf-8');
      written = true;
    }

    results.push({
      repoId: '_global',
      repoName: 'Global',
      path: globalPath,
      content,
      written,
      ruleCount,
    });

    return {
      mode: 'global',
      results,
      totalRules: ruleCount,
      filesWritten: written ? 1 : 0,
    };
  }

  // Per-repo mode (default)
  const enabledRepos = getEnabledRepos(manifest);

  for (const repo of enabledRepos) {
    const result = writeRepoIgnore(repo, root, options);
    results.push(result);
  }

  const totalRules = results.reduce((sum, r) => sum + r.ruleCount, 0);
  const filesWritten = results.filter((r) => r.written).length;

  return {
    mode: 'perRepo',
    results,
    totalRules,
    filesWritten,
  };
}

/**
 * Read existing ignore file from a repo
 */
export function readRepoIgnore(repoPath: string): string | null {
  const ignorePath = path.join(repoPath, '.mgrepignore');
  if (fs.existsSync(ignorePath)) {
    return fs.readFileSync(ignorePath, 'utf-8');
  }
  return null;
}

/**
 * Check if repo has an existing .mgrepignore
 */
export function hasIgnoreFile(repoPath: string): boolean {
  return fs.existsSync(path.join(repoPath, '.mgrepignore'));
}
